<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>CloudWalk Monitoring Dashboard</title>
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<style>
		* { margin: 0; padding: 0; box-sizing: border-box; }
		body { font-family: 'Arial', sans-serif; background-color: #f5f5f5; color: #333; }
		.header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 1rem; text-align: center; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
		.container { max-width: 1400px; margin: 0 auto; padding: 2rem; }
		.status-bar { display: flex; justify-content: space-between; align-items: center; background: white; padding: 1rem; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 2rem; }
		.status-indicator { display: flex; align-items: center; gap: 0.5rem; }
		.status-dot { width: 12px; height: 12px; border-radius: 50%; background-color: #28a745; }
		.status-dot.warning { background-color: #ffc107; }
		.status-dot.danger { background-color: #dc3545; }
		.dashboard-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 2rem; }
		.card { background: white; border-radius: 8px; padding: 1.5rem; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
		.card h3 { margin-bottom: 1rem; color: #333; border-bottom: 2px solid #eee; padding-bottom: 0.5rem; }
		.metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem; }
		.metric-card { background: white; padding: 1.5rem; border-radius: 8px; text-align: center; box-shadow: 0 2px 10px rgba(0,0,0,0.1); border-left: 4px solid #667eea; }
		.metric-value { font-size: 2rem; font-weight: bold; color: #333; margin-bottom: 0.5rem; }
		.metric-label { color: #666; text-transform: uppercase; font-size: 0.9rem; letter-spacing: 1px; }
		.alerts-container { background: white; border-radius: 8px; padding: 1.5rem; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 2rem; }
		.alert { padding: 1rem; margin: 0.5rem 0; border-radius: 4px; border-left: 4px solid; background: #f8f9fa; }
		.alert.high { border-left-color: #dc3545; background: #f8d7da; }
		.alert.medium { border-left-color: #ffc107; background: #fff3cd; }
		.alert.low { border-left-color: #28a745; background: #d4edda; }
		.alert-time { font-size: 0.8rem; color: #666; margin-bottom: 0.5rem; }
		.alert-message { font-weight: bold; }
		.chart-container { position: relative; height: 400px; margin: 1rem 0; }
		.connection-status { padding: 0.5rem 1rem; border-radius: 20px; font-size: 0.9rem; font-weight: bold; }
		.connected { background: #d4edda; color: #155724; }
		.disconnected { background: #f8d7da; color: #721c24; }
		.full-width { grid-column: 1 / -1; }
		.notification { position: fixed; top: 20px; right: 20px; padding: 1rem; border-radius: 8px; color: white; font-weight: bold; z-index: 1000; opacity: 0; transform: translateX(100%); transition: all 0.3s ease; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
		.notification.show { opacity: 1; transform: translateX(0); }
		.notification.high { background: linear-gradient(135deg, #dc3545, #c82333); }
		.notification.medium { background: linear-gradient(135deg, #ffc107, #e0a800); color: #333; }
		.notification.low { background: linear-gradient(135deg, #28a745, #1e7e34); }
		.notification .close-btn { float: right; margin-left: 10px; cursor: pointer; font-size: 1.2rem; }
		@media (max-width: 768px) { .dashboard-grid { grid-template-columns: 1fr; } .metrics-grid { grid-template-columns: 1fr; } .notification { right: 10px; left: 10px; transform: translateY(-100%); } .notification.show { transform: translateY(0); } }
	</style>
	</head>
<body>
	<div class="header">
		<h1>CloudWalk Transaction Monitoring Dashboard</h1>
		<p>Real-time anomaly detection and transaction analysis</p>
	</div>
    
	<!-- Notification container -->
	<div id="notificationContainer"></div>
	
	<div class="container">
		<div class="status-bar">
			<div class="status-indicator">
				<div class="status-dot" id="systemStatus"></div>
				<span id="systemStatusText">System Status: Normal</span>
			</div>
			<div class="connection-status connected" id="connectionStatus">WebSocket: Connected</div>
			<div id="lastUpdate">
				Last Update: <span id="lastUpdateTime">-</span>
				<button id="refreshBtn" style="margin-left:10px;padding:6px 12px;border:1px solid #ccc;border-radius:6px;background:#fff;cursor:pointer;">Refresh</button>
				<select id="hoursSelect" style="margin-left:8px;">
					<option value="1">1h</option>
					<option value="6">6h</option>
					<option value="24" selected>24h</option>
					<option value="720">30d</option>
					<option value="4320">6m</option>
				</select>
			</div>
		</div>
        
		<div class="metrics-grid">
			<div class="metric-card">
				<div class="metric-value" id="totalTransactions">0</div>
				<div class="metric-label" id="totalTransactionsLabel">Total Transactions (24h)</div>
			</div>
			<div class="metric-card">
				<div class="metric-value" id="approvedRate">0%</div>
				<div class="metric-label">Approval Rate</div>
			</div>
			<div class="metric-card">
				<div class="metric-value" id="failedCount">0</div>
				<div class="metric-label">Failed Transactions</div>
			</div>
			<div class="metric-card">
				<div class="metric-value" id="activeAlerts">0</div>
				<div class="metric-label">Active Alerts</div>
			</div>
		</div>
        
		<div class="dashboard-grid">
			<div class="card">
				<h3>Transaction Status Distribution</h3>
				<div class="chart-container">
					<canvas id="statusChart"></canvas>
				</div>
			</div>
            
			<div class="card">
				<h3>Transaction Volume Over Time</h3>
				<div class="chart-container">
					<canvas id="timeSeriesChart"></canvas>
				</div>
			</div>
		</div>
        
		<div class="card full-width">
			<h3>Checkout Analysis - Hourly Comparison</h3>
			<div class="chart-container">
				<canvas id="checkoutChart"></canvas>
			</div>
		</div>
        
		<div class="alerts-container">
			<h3>Recent Alerts</h3>
			<div id="alertsList">
				<p>No alerts at the moment.</p>
			</div>
		</div>
	</div>

	<script>
		class MonitoringDashboard {
			constructor() {
				this.ws = null;
				this.charts = {};
				this.alertsCount = 0;
				this.hours = 24;
				this.connectWebSocket();
				this.initializeCharts();
				this.loadInitialData();
				this.setupPeriodicUpdates();
				this.bindControls();
			}
            
			getWindowLabel(hours) {
				switch (hours) {
					case 1: return '1h';
					case 6: return '6h';
					case 24: return '24h';
					case 720: return '30d';
					case 4320: return '6m';
					default: return `${hours}h`;
				}
			}
            
			connectWebSocket() {
				try {
					this.ws = new WebSocket('ws://localhost:8080');
                    
					this.ws.onopen = () => {
						console.log('WebSocket connected');
						this.updateConnectionStatus(true);
					};
                    
					this.ws.onmessage = (event) => {
						const message = JSON.parse(event.data);
						this.handleWebSocketMessage(message);
					};
                    
					this.ws.onclose = () => {
						console.log('WebSocket disconnected');
						this.updateConnectionStatus(false);
						// Reconnect after 5 seconds
						setTimeout(() => this.connectWebSocket(), 5000);
					};
                    
					this.ws.onerror = (error) => {
						console.error('WebSocket error:', error);
						this.updateConnectionStatus(false);
					};
				} catch (error) {
					console.error('Failed to connect WebSocket:', error);
					this.updateConnectionStatus(false);
				}
			}
            
			updateConnectionStatus(connected) {
				const statusElement = document.getElementById('connectionStatus');
				if (connected) {
					statusElement.className = 'connection-status connected';
					statusElement.textContent = 'WebSocket: Connected';
				} else {
					statusElement.className = 'connection-status disconnected';
					statusElement.textContent = 'WebSocket: Disconnected';
				}
			}
            
			handleWebSocketMessage(message) {
				switch (message.type) {
					case 'alert':
					case 'scheduled_alert':
						this.addAlert(message.data);
						this.updateSystemStatus(message.data.severity);
						this.showNotification(message.data);
						this.playAlertSound(message.data.severity);
						break;
					case 'transaction':
						this.updateLastUpdateTime();
						break;
				}
			}
            
			initializeCharts() {
				// Status Distribution Chart
				const statusCtx = document.getElementById('statusChart').getContext('2d');
				this.charts.status = new Chart(statusCtx, {
					type: 'doughnut',
					data: { labels: [], datasets: [{ data: [], backgroundColor: [ '#28a745', '#dc3545', '#ffc107', '#17a2b8', '#6f42c1', '#fd7e14' ] }] },
					options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'bottom' } } }
				});
                
				// Time Series Chart
				const timeCtx = document.getElementById('timeSeriesChart').getContext('2d');
				this.charts.timeSeries = new Chart(timeCtx, {
					type: 'line',
					data: { labels: [], datasets: [] },
					options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true } }, plugins: { legend: { position: 'top' } } }
				});
                
				// Checkout Analysis Chart
				const checkoutCtx = document.getElementById('checkoutChart').getContext('2d');
				this.charts.checkout = new Chart(checkoutCtx, {
					type: 'bar',
					data: { labels: [], datasets: [] },
					options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true } }, plugins: { legend: { position: 'top' } } }
				});
			}
            
			async loadInitialData() {
				try {
					await Promise.all([
						this.updateStats(),
						this.updateTimeSeriesChart(),
						this.updateCheckoutChart(),
						this.updateAlerts()
					]);
				} catch (error) {
					console.error('Error loading initial data:', error);
				}
			}
			bindControls() {
				const refreshBtn = document.getElementById('refreshBtn');
				const hoursSelect = document.getElementById('hoursSelect');
				refreshBtn.addEventListener('click', () => this.refreshAll());
				hoursSelect.addEventListener('change', (e) => { this.hours = parseInt(e.target.value, 10); this.refreshAll(); });
			}
			async refreshAll() {
				await Promise.all([
					this.updateStats(),
					this.updateTimeSeriesChart(),
					this.updateAlerts(),
					this.updateCheckoutChart(),
				]);
				this.updateLastUpdateTime();
			}
            
			async updateStats() {
				try {
					const response = await fetch(`/api/stats?hours=${this.hours}`);
					const stats = await response.json();
                    
					let totalTransactions = 0;
					let approvedCount = 0;
					let failedCount = 0;
                    
					const labels = [];
					const data = [];
                    
					stats.forEach(stat => {
						totalTransactions += stat.sum_count;
						labels.push(stat.status);
						data.push(stat.sum_count);
                        
						if (stat.status === 'approved') { approvedCount = stat.sum_count; }
						else if (stat.status === 'failed') { failedCount = stat.sum_count; }
					});
                    
					const approvalRate = totalTransactions > 0 ? ((approvedCount / totalTransactions) * 100).toFixed(1) : 0;
                    
					// Update metrics
					document.getElementById('totalTransactions').textContent = totalTransactions.toLocaleString();
					const windowLabel = this.getWindowLabel(this.hours);
					document.getElementById('totalTransactionsLabel').textContent = `Total Transactions (${windowLabel})`;
					document.getElementById('approvedRate').textContent = approvalRate + '%';
					document.getElementById('failedCount').textContent = failedCount.toLocaleString();
                    
					// Update status chart
					this.charts.status.data.labels = labels;
					this.charts.status.data.datasets[0].data = data;
					this.charts.status.update();
                    
				} catch (error) {
					console.error('Error updating stats:', error);
				}
			}
            
			async updateTimeSeriesChart() {
				try {
					const hours = Math.min(this.hours, 24); // cap timeseries to 24h for readability
					const response = await fetch(`/api/timeseries?hours=${hours}`);
					const data = await response.json();
                    
					const groupedData = {};
					data.forEach(item => {
						if (!groupedData[item.status]) { groupedData[item.status] = []; }
						// Use time from server directly since it's already in local timezone
						const timeStr = item.time_local || item.time;
						const timeDate = new Date(timeStr);
						const formattedTime = timeDate.toLocaleString('pt-BR', {
							hour: '2-digit', minute: '2-digit'
						});
						groupedData[item.status].push({ x: formattedTime, y: item.total_count });
					});
                    
					const datasets = Object.keys(groupedData).map((status) => ({
						label: status,
						data: groupedData[status],
						borderColor: this.getStatusColor(status),
						backgroundColor: this.getStatusColor(status, 0.1),
						fill: false,
						tension: 0.1
					}));
                    
					this.charts.timeSeries.data.datasets = datasets;
					this.charts.timeSeries.update();
                    
				} catch (error) {
					console.error('Error updating time series chart:', error);
				}
			}
            
			async updateCheckoutChart() {
				try {
					const response = await fetch('/api/checkout-analysis');
					const data = await response.json();
                    
					if (!data || data.length === 0) {
						console.warn('No checkout data available');
						return;
					}
                    
					const checkout1 = data.filter(item => item.dataset_name === 'checkout_1');
					const checkout2 = data.filter(item => item.dataset_name === 'checkout_2');
                    
					if (checkout1.length === 0 && checkout2.length === 0) {
						console.warn('No checkout datasets found');
						return;
					}
                    
					// Use checkout1 for hours, fallback to checkout2 if checkout1 is empty
					const primaryData = checkout1.length > 0 ? checkout1 : checkout2;
					const hours = primaryData.map(item => item.time);
                    
					const datasets = [];
                    
					if (checkout1.length > 0) {
						datasets.push(
							{ label: 'Today (Checkout 1)', data: checkout1.map(item => parseInt(item.today) || 0), backgroundColor: 'rgba(54, 162, 235, 0.8)' },
							{ label: 'Yesterday (Checkout 1)', data: checkout1.map(item => parseInt(item.yesterday) || 0), backgroundColor: 'rgba(255, 99, 132, 0.8)' },
							{ label: 'Week Average (Checkout 1)', data: checkout1.map(item => parseFloat(item.avg_last_week) || 0), backgroundColor: 'rgba(75, 192, 192, 0.8)' }
						);
					}
                    
					if (checkout2.length > 0) {
						datasets.push(
							{ label: 'Today (Checkout 2)', data: checkout2.map(item => parseInt(item.today) || 0), backgroundColor: 'rgba(153, 102, 255, 0.8)' },
							{ label: 'Week Average (Checkout 2)', data: checkout2.map(item => parseFloat(item.avg_last_week) || 0), backgroundColor: 'rgba(255, 159, 64, 0.8)' }
						);
					}
                    
					this.charts.checkout.data.labels = hours;
					this.charts.checkout.data.datasets = datasets;
					this.charts.checkout.update();
                    
				} catch (error) {
					console.error('Error updating checkout chart:', error);
				}
			}
            
			async updateAlerts() {
				try {
					const response = await fetch('/api/alerts?limit=20');
					const alerts = await response.json();
                    
					const alertsList = document.getElementById('alertsList');
					if (alerts.length === 0) {
						alertsList.innerHTML = '<p>No alerts at the moment.</p>';
						this.alertsCount = 0;
					} else {
						alertsList.innerHTML = alerts.map(alert => {
							const alertTime = new Date(alert.timestamp);
							const options = { 
								year: 'numeric', month: '2-digit', day: '2-digit',
								hour: '2-digit', minute: '2-digit', second: '2-digit'
							};
							const formattedTime = alertTime.toLocaleString('pt-BR', options);
							return `
								<div class="alert ${alert.severity}">
									<div class="alert-time">${formattedTime}</div>
									<div class="alert-message">${alert.message}</div>
								</div>
							`;
						}).join('');
						this.alertsCount = alerts.filter(a => a.severity === 'high').length;
					}
					document.getElementById('activeAlerts').textContent = this.alertsCount;
				} catch (error) {
					console.error('Error updating alerts:', error);
				}
			}
            
			addAlert(alert) {
				const alertsList = document.getElementById('alertsList');
				const el = document.createElement('div');
				el.className = `alert ${alert.severity}`;
				
				// Format time with local timezone
				const now = new Date();
				const options = { 
					year: 'numeric', month: '2-digit', day: '2-digit',
					hour: '2-digit', minute: '2-digit', second: '2-digit'
				};
				const formattedTime = now.toLocaleString('pt-BR', options);
				
				el.innerHTML = `
					<div class="alert-time">${formattedTime}</div>
					<div class="alert-message">${alert.message}</div>
				`;
				alertsList.insertBefore(el, alertsList.firstChild);
				const alerts = alertsList.querySelectorAll('.alert');
				if (alerts.length > 20) alerts[alerts.length - 1].remove();
				if (alert.severity === 'high') { this.alertsCount++; document.getElementById('activeAlerts').textContent = this.alertsCount; }
			}
            
			updateSystemStatus(severity) {
				const statusDot = document.getElementById('systemStatus');
				const statusText = document.getElementById('systemStatusText');
				if (severity === 'high') { statusDot.className = 'status-dot danger'; statusText.textContent = 'System Status: Critical Alert'; }
				else if (severity === 'medium') { statusDot.className = 'status-dot warning'; statusText.textContent = 'System Status: Warning'; }
				else { statusDot.className = 'status-dot'; statusText.textContent = 'System Status: Normal'; }
			}
            
			updateLastUpdateTime() { 
				const now = new Date();
				const options = { 
					year: 'numeric', month: '2-digit', day: '2-digit',
					hour: '2-digit', minute: '2-digit', second: '2-digit'
				};
				document.getElementById('lastUpdateTime').textContent = now.toLocaleString('pt-BR', options);
			}
			
			showNotification(alert) {
				const container = document.getElementById('notificationContainer');
				const notification = document.createElement('div');
				notification.className = `notification ${alert.severity}`;
				
				const icon = alert.severity === 'high' ? '🚨' : alert.severity === 'medium' ? '⚠️' : 'ℹ️';
				notification.innerHTML = `
					<span class="close-btn" onclick="this.parentElement.remove()">&times;</span>
					${icon} <strong>Alert:</strong> ${alert.message}
				`;
				
				container.appendChild(notification);
				
				// Show notification
				setTimeout(() => notification.classList.add('show'), 100);
				
				// Auto-remove after 10 seconds for low/medium, 15 seconds for high
				const timeout = alert.severity === 'high' ? 15000 : 10000;
				setTimeout(() => {
					if (notification.parentElement) {
						notification.classList.remove('show');
						setTimeout(() => notification.remove(), 300);
					}
				}, timeout);
			}
			
			playAlertSound(severity) {
				try {
					// Create audio context for different alert sounds
					const audioContext = new (window.AudioContext || window.webkitAudioContext)();
					const oscillator = audioContext.createOscillator();
					const gainNode = audioContext.createGain();
					
					oscillator.connect(gainNode);
					gainNode.connect(audioContext.destination);
					
					// Different frequencies for different severities
					if (severity === 'high') {
						// High priority: urgent pattern
						oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
						oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1);
						oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.2);
						gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
						gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
						oscillator.start(audioContext.currentTime);
						oscillator.stop(audioContext.currentTime + 0.4);
					} else if (severity === 'medium') {
						// Medium priority: single beep
						oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
						gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
						gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
						oscillator.start(audioContext.currentTime);
						oscillator.stop(audioContext.currentTime + 0.2);
					}
					// Low priority: no sound
				} catch (error) {
					console.log('Audio not supported or blocked:', error);
				}
			}
            
			getStatusColor(status, alpha = 1) {
				const colors = {
					'approved': `rgba(40, 167, 69, ${alpha})`,
					'failed': `rgba(220, 53, 69, ${alpha})`,
					'denied': `rgba(255, 193, 7, ${alpha})`,
					'reversed': `rgba(23, 162, 184, ${alpha})`,
					'backend_reversed': `rgba(111, 66, 193, ${alpha})`,
					'refunded': `rgba(253, 126, 20, ${alpha})`
				};
				return colors[status] || `rgba(108, 117, 125, ${alpha})`;
			}
            
			setupPeriodicUpdates() {
				setInterval(() => {
					this.updateStats();
					this.updateTimeSeriesChart();
					this.updateAlerts();
				}, 30000);
				setInterval(() => { this.updateCheckoutChart(); }, 300000);
			}
		}
		document.addEventListener('DOMContentLoaded', () => { new MonitoringDashboard(); });
	</script>
</body>
</html>

